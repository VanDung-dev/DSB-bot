import asyncio
import json
import logging
from collections import deque
from pathlib import Path
from typing import Dict, Optional

import discord
import yt_dlp
import os
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
from dotenv import load_dotenv
from discord.ext import commands
from discord import app_commands

# C·∫•u h√¨nh logger
logger = logging.getLogger(__name__)


def is_spotify_url(url: str) -> bool:
    return "open.spotify.com" in url


class MusicSearch(commands.Cog):
    """Cog x·ª≠ l√Ω c√°c l·ªánh ph√°t nh·∫°c t·ª´ YouTube."""

    FFMPEG_OPTIONS = {
        "before_options": (
            "-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5 "
            "-headers 'User-Agent: Mozilla/5.0'"
        ),
        "options": "-vn",
    }

    def __init__(self, bot: commands.Bot) -> None:
        """Kh·ªüi t·∫°o cog MusicSearch.

        Args:
            bot: ƒê·ªëi t∆∞·ª£ng bot Discord.
        """
        self.bot = bot
        self.queues: Dict[int, deque] = {}
        self.now_playing: Dict[int, dict] = {}
        self.voice_clients: Dict[int, discord.VoiceClient] = {}
        self.ydl_options = self.load_ydl_config()
        self.inactivity_timers: Dict[int, asyncio.Task] = {}

        load_dotenv()
        client_id = os.getenv("SPOTIFY_CLIENT_ID")
        client_secret = os.getenv("SPOTIFY_CLIENT_SECRET")

        self.sp = None
        if client_id and client_secret:
            self.sp = spotipy.Spotify(
                auth_manager=SpotifyClientCredentials(
                    client_id=client_id,
                    client_secret=client_secret
                )
            )

        self.locks: Dict[int, asyncio.Lock] = {}

    @staticmethod
    def load_ydl_config() -> dict:
        """T·∫£i c·∫•u h√¨nh yt_dlp t·ª´ file JSON.

        Returns:
            C·∫•u h√¨nh yt_dlp.

        Raises:
            FileNotFoundError: N·∫øu file ydl_config.json kh√¥ng t·ªìn t·∫°i.
            json.JSONDecodeError: N·∫øu file JSON kh√¥ng h·ª£p l·ªá.
        """
        config_file = Path("ydl_config.json")
        try:
            if config_file.exists():
                with config_file.open("r", encoding="utf-8") as f:
                    return json.load(f)
            raise FileNotFoundError("ydl_config.json kh√¥ng t·ªìn t·∫°i")
        except json.JSONDecodeError as e:
            logger.error(f"‚ùå L·ªói khi ƒë·ªçc ydl_config.json: {e}")
            raise
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi t·∫£i ydl_config.json: {e}")
            raise

    @staticmethod
    def is_spotify_url(url: str) -> bool:
        return "open.spotify.com" in url

    def get_spotify_queries(self, url: str) -> list[str]:
        """Tr·∫£ v·ªÅ danh s√°ch query nh·∫°c t·ª´ Spotify (track/album/playlist)."""
        if not self.sp:
            return []

        queries = []
        try:
            if "track" in url:
                track = self.sp.track(url)
                queries.append(f"{track['name']} {track['artists'][0]['name']}")
            elif "album" in url:
                album_id = url.split("/")[-1].split("?")[0]
                tracks = self.sp.album_tracks(album_id)
                for t in tracks["items"]:
                    queries.append(f"{t['name']} {t['artists'][0]['name']}")
            elif "playlist" in url:
                playlist_id = url.split("/")[-1].split("?")[0]
                tracks = self.sp.playlist_tracks(playlist_id)
                for item in tracks["items"]:
                    t = item["track"]
                    queries.append(f"{t['name']} {t['artists'][0]['name']}")
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi l·∫•y d·ªØ li·ªáu Spotify: {e}")

        return queries

    async def get_video_info(self, query: str, use_cookies: bool = False) -> Optional[dict]:
        """L·∫•y th√¥ng tin video t·ª´ YouTube.

        Args:
            query: URL ho·∫∑c t·ª´ kh√≥a t√¨m ki·∫øm.
            use_cookies: C√≥ s·ª≠ d·ª•ng cookie ƒë·ªÉ x√°c th·ª±c hay kh√¥ng.

        Returns:
            Th√¥ng tin video (title, url, webpage_url, duration, uploader) ho·∫∑c None n·∫øu l·ªói.
        """
        temp_cookies_path = None
        youtube_cookies = None
        try:
            # √©p bu·ªôc kh√¥ng simulate
            ydl_opts = self.ydl_options.copy()
            ydl_opts.pop("simulate", None)

            if use_cookies:
                youtube_cookies = os.getenv("YOUTUBE_COOKIES")
                if youtube_cookies:
                    temp_cookies_path = "temp_cookies.txt"
                    with open(temp_cookies_path, "w", encoding="utf-8") as f:
                        f.write(youtube_cookies)
                    ydl_opts["cookiefile"] = temp_cookies_path
                elif "cookiefile" not in ydl_opts:
                    cookies_path = Path("cookies.txt")
                    if cookies_path.exists():
                        ydl_opts["cookiefile"] = str(cookies_path)

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                loop = asyncio.get_event_loop()
                info = await loop.run_in_executor(None, lambda: ydl.extract_info(query, download=False))
                if "entries" in info:
                    info = info["entries"][0]

                stream_url = info.get("url")

                return {
                    "title": info.get("title", "Unknown Title"),
                    "url": stream_url,
                    "webpage_url": info.get("webpage_url", ""),
                    "duration": info.get("duration", 0),
                    "uploader": info.get("uploader", "Unknown Uploader"),
                }
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi t·∫£i th√¥ng tin video: {e}")
            return None
        finally:
            if use_cookies and temp_cookies_path and os.path.exists(temp_cookies_path):
                os.remove(temp_cookies_path)

    async def disconnect_after_inactivity(self, guild_id: int, delay: int = 60) -> None:
        """Ng·∫Øt k·∫øt n·ªëi sau m·ªôt kho·∫£ng th·ªùi gian kh√¥ng ho·∫°t ƒë·ªông."""
        await asyncio.sleep(delay)
        
        # Ki·ªÉm tra n·∫øu v·∫´n kh√¥ng c√≥ ho·∫°t ƒë·ªông n√†o
        if guild_id in self.queues and len(self.queues[guild_id]) > 0:
            return  # C√≥ b√†i h√°t trong h√†ng ƒë·ª£i, kh√¥ng ng·∫Øt k·∫øt n·ªëi
            
        if guild_id in self.now_playing:
            return  # V·∫´n ƒëang ph√°t nh·∫°c, kh√¥ng ng·∫Øt k·∫øt n·ªëi
            
        # Ki·ªÉm tra n·∫øu c√≥ bot ƒëang n√≥i
        speaking_cog = self.bot.get_cog('Speaking')
        if speaking_cog and guild_id in speaking_cog.speaking_states:
            return  # Bot ƒëang n√≥i, kh√¥ng ng·∫Øt k·∫øt n·ªëi
            
        # Ng·∫Øt k·∫øt n·ªëi do kh√¥ng ho·∫°t ƒë·ªông
        if guild_id in self.voice_clients:
            await self.voice_clients[guild_id].disconnect()
            self.voice_clients.pop(guild_id)
            logger.info(f"‚úÖ ƒê√£ ng·∫Øt k·∫øt n·ªëi kh·ªèi voice channel do kh√¥ng ho·∫°t ƒë·ªông trong guild {guild_id}")

    def reset_inactivity_timer(self, guild_id: int) -> None:
        """ƒê·∫∑t l·∫°i b·ªô ƒë·∫øm th·ªùi gian kh√¥ng ho·∫°t ƒë·ªông."""
        # H·ªßy b·ªô ƒë·∫øm th·ªùi gian tr∆∞·ªõc ƒë√≥ n·∫øu c√≥
        if guild_id in self.inactivity_timers:
            self.inactivity_timers[guild_id].cancel()
            
        # T·∫°o b·ªô ƒë·∫øm th·ªùi gian m·ªõi
        self.inactivity_timers[guild_id] = asyncio.create_task(
            self.disconnect_after_inactivity(guild_id)
        )

    async def play_next(self, guild_id: int) -> None:
        """Ph√°t b√†i ti·∫øp theo trong h√†ng ƒë·ª£i.

        Args:
            guild_id: ID c·ªßa server Discord.
        """
        if guild_id not in self.queues or not self.queues[guild_id]:
            self.now_playing.pop(guild_id, None)
            # ƒê·∫∑t b·ªô ƒë·∫øm th·ªùi gian ƒë·ªÉ ng·∫Øt k·∫øt n·ªëi sau 1 ph√∫t kh√¥ng ho·∫°t ƒë·ªông
            self.reset_inactivity_timer(guild_id)
            return

        song = self.queues[guild_id].popleft()
        self.now_playing[guild_id] = song

        try:
            source = discord.FFmpegPCMAudio(song["url"], **self.FFMPEG_OPTIONS)
            voice_client = self.voice_clients[guild_id]
            speaking_cog = self.bot.get_cog('Speaking')
            while voice_client.is_playing() or (speaking_cog and guild_id in speaking_cog.speaking_states):
                await asyncio.sleep(0.5)
            voice_client.play(
                source,
                after=lambda e: asyncio.run_coroutine_threadsafe(self.play_next(guild_id), self.bot.loop),
            )
            # G·ª≠i embed v√†o channel g·ªëc c·ªßa l·ªánh, n·∫øu c√≥
            text_channel = song.get("origin_channel")
            if text_channel is not None:
                embed = discord.Embed(
                    title="üéµ ƒêang ph√°t",
                    description=(
                        f"[{song['title']}]({song['webpage_url']})\n"
                        f"**Ng∆∞·ªùi t·∫£i l√™n**: {song['uploader']}\n"
                        f"**Th·ªùi l∆∞·ª£ng**: {song['duration']//60}:{song['duration']%60:02d}"
                    ),
                    color=discord.Color.green(),
                )
                await text_channel.send(embed=embed)
            logger.info(f"‚úÖ ƒêang ph√°t: {song['title']} trong guild {guild_id}")
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi ph√°t nh·∫°c: {e}")
            await self.play_next(guild_id)

    @commands.command(name="play", aliases=["p"])
    async def play(self, ctx: commands.Context, *, query: str) -> None:
        guild_id = ctx.guild.id

        if guild_id not in self.locks:
            self.locks[guild_id] = asyncio.Lock()

        async with self.locks[guild_id]:
            if not ctx.author.voice:
                await ctx.send("‚ùå B·∫°n c·∫ßn ·ªü trong voice channel ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y.")
                return

            voice_channel = ctx.author.voice.channel

            if guild_id not in self.voice_clients:
                try:
                    self.voice_clients[guild_id] = await voice_channel.connect()
                except discord.errors.ClientException:
                    await ctx.send("‚ùå Bot ƒë√£ ·ªü trong voice channel kh√°c.")
                    return
                except Exception as e:
                    logger.error(f"‚ùå L·ªói khi k·∫øt n·ªëi voice channel: {e}")
                    await ctx.send("‚ùå L·ªói khi k·∫øt n·ªëi voice channel.")
                    return

            # H·ªßy b·ªô ƒë·∫øm th·ªùi gian kh√¥ng ho·∫°t ƒë·ªông khi c√≥ y√™u c·∫ßu m·ªõi
            if guild_id in self.inactivity_timers:
                self.inactivity_timers[guild_id].cancel()
                self.inactivity_timers.pop(guild_id)

            # Ki·ªÉm tra xem bot c√≥ ƒëang n√≥i kh√¥ng
            speaking_cog = self.bot.get_cog('Speaking')
            if speaking_cog and guild_id in speaking_cog.speaking_states:
                await ctx.send("‚ùå Bot ƒëang n√≥i, vui l√≤ng ƒë·ª£i n√≥i xong r·ªìi ph√°t nh·∫°c.")
                return

            # Ki·ªÉm tra n·∫øu l√† link Spotify
            if self.is_spotify_url(query):
                queries = self.get_spotify_queries(query)
                if not queries:
                    await ctx.send("‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c nh·∫°c t·ª´ Spotify.")
                    return

                first = True
                for q in queries:
                    # L·∫•y th√¥ng tin video l·∫ßn 1 (kh√¥ng d√πng cookie)
                    video_info = await self.get_video_info(q)

                    # N·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin, th·ª≠ l·∫°i l·∫ßn 2 (c√≥ d√πng cookie)
                    if not video_info:
                        logger.warning(f"Kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin video cho '{q}' l·∫ßn 1, th·ª≠ l·∫°i v·ªõi cookie...")
                        video_info = await self.get_video_info(q, use_cookies=True)

                    if not video_info:
                        continue

                    if guild_id not in self.queues:
                        self.queues[guild_id] = deque()
                    # L∆∞u channel g·ªëc v√†o dict b√†i h√°t
                    video_info["origin_channel"] = ctx.channel
                    self.queues[guild_id].append(video_info)

                    if first:
                        if guild_id in self.now_playing:
                            embed = discord.Embed(
                                title="‚úÖ ƒê√£ th√™m t·ª´ Spotify v√†o h√†ng ƒë·ª£i",
                                description=f"[{video_info['title']}]({video_info['webpage_url']})",
                                color=discord.Color.blue(),
                            )
                            await ctx.send(embed=embed)
                        else:
                            embed = discord.Embed(
                                title="üéµ ƒêang ph√°t t·ª´ Spotify",
                                description=f"[{video_info['title']}]({video_info['webpage_url']})",
                                color=discord.Color.green(),
                            )
                            await ctx.send(embed=embed)
                            await self.play_next(guild_id)
                        first = False
                return

            # N·∫øu l√† YouTube ho·∫∑c search
            search_msg = await ctx.send(f"üîç ƒêang t√¨m: **{query}**...")
            # L·∫•y th√¥ng tin video l·∫ßn 1 (kh√¥ng d√πng cookie)
            video_info = await self.get_video_info(query)
            
            # N·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin, th·ª≠ l·∫°i l·∫ßn 2 (c√≥ d√πng cookie)
            if not video_info:
                logger.warning(f"Kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin video cho '{query}' l·∫ßn 1, th·ª≠ l·∫°i v·ªõi cookie...")
                video_info = await self.get_video_info(query, use_cookies=True)
            
            if not video_info:
                await ctx.send(f"‚ùå Kh√¥ng t√¨m th·∫•y video cho '{query}'.")
                return

            if guild_id not in self.queues:
                self.queues[guild_id] = deque()
            video_info["origin_channel"] = ctx.channel
            self.queues[guild_id].append(video_info)

            embed = discord.Embed(
                title="‚úÖ ƒê√£ th√™m v√†o h√†ng ƒë·ª£i",
                description=f"[{video_info['title']}]({video_info['webpage_url']})",
                color=discord.Color.blue(),
            )
            await search_msg.edit(content="", embed=embed)

            if guild_id not in self.now_playing:
                await self.play_next(guild_id)

    @app_commands.command(name="play", description="Ph√°t nh·∫°c ho·∫∑c th√™m v√†o h√†ng ƒë·ª£i")
    @app_commands.describe(query="URL ho·∫∑c t·ª´ kh√≥a t√¨m ki·∫øm")
    async def slash_play(self, interaction: discord.Interaction, query: str) -> None:
        """Slash command ph√°t nh·∫°c ho·∫∑c th√™m v√†o h√†ng ƒë·ª£i.

        Args:
            interaction: T∆∞∆°ng t√°c t·ª´ ng∆∞·ªùi d√πng.
            query: URL ho·∫∑c t·ª´ kh√≥a t√¨m ki·∫øm.
        """
        guild_id = interaction.guild.id

        if guild_id not in self.locks:
            self.locks[guild_id] = asyncio.Lock()

        async with self.locks[guild_id]:
            await interaction.response.send_message(f"üîç ƒêang t√¨m: **{query}**...", ephemeral=False)

            if not interaction.user.voice:
                await interaction.edit_original_response(content="‚ùå B·∫°n c·∫ßn ·ªü trong voice channel ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y.")
                return

            voice_channel = interaction.user.voice.channel

            if guild_id not in self.voice_clients:
                try:
                    self.voice_clients[guild_id] = await voice_channel.connect()
                except discord.errors.ClientException:
                    await interaction.edit_original_response(content="‚ùå Bot ƒë√£ ·ªü trong voice channel kh√°c.")
                    return
                except Exception as e:
                    logger.error(f"‚ùå L·ªói khi k·∫øt n·ªëi voice channel: {e}")
                    await interaction.edit_original_response(content="‚ùå L·ªói khi k·∫øt n·ªëi voice channel.")
                    return

            # H·ªßy b·ªô ƒë·∫øm th·ªùi gian kh√¥ng ho·∫°t ƒë·ªông khi c√≥ y√™u c·∫ßu m·ªõi
            if guild_id in self.inactivity_timers:
                self.inactivity_timers[guild_id].cancel()
                self.inactivity_timers.pop(guild_id)

            # Ki·ªÉm tra xem bot c√≥ ƒëang n√≥i kh√¥ng
            speaking_cog = self.bot.get_cog('Speaking')
            if speaking_cog and guild_id in speaking_cog.speaking_states:
                await interaction.edit_original_response(content="‚ùå Bot ƒëang n√≥i, vui l√≤ng ƒë·ª£i n√≥i xong r·ªìi ph√°t nh·∫°c.")
                return

            # Ki·ªÉm tra n·∫øu l√† link Spotify
            if self.is_spotify_url(query):
                queries = self.get_spotify_queries(query)
                if not queries:
                    await interaction.edit_original_response(content="‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c nh·∫°c t·ª´ Spotify.")
                    return

                first = True
                for q in queries:
                    video_info = await self.get_video_info(q)
                    if not video_info:
                        continue

                    if guild_id not in self.queues:
                        self.queues[guild_id] = deque()
                    # L∆∞u channel g·ªëc v√†o dict b√†i h√°t
                    video_info["origin_channel"] = interaction.channel
                    self.queues[guild_id].append(video_info)

                    if first:
                        if guild_id in self.now_playing:
                            embed = discord.Embed(
                                title="‚úÖ ƒê√£ th√™m t·ª´ Spotify v√†o h√†ng ƒë·ª£i",
                                description=f"[{video_info['title']}]({video_info['webpage_url']})",
                                color=discord.Color.blue(),
                            )
                            await interaction.edit_original_response(content="", embed=embed)
                        else:
                            embed = discord.Embed(
                                title="üéµ ƒêang ph√°t t·ª´ Spotify",
                                description=f"[{video_info['title']}]({video_info['webpage_url']})",
                                color=discord.Color.green(),
                            )
                            await interaction.edit_original_response(content="", embed=embed)
                            await self.play_next(guild_id)
                        first = False
                return

            # N·∫øu kh√¥ng ph·∫£i Spotify ‚Üí x·ª≠ l√Ω nh∆∞ c≈© (YouTube)
            # L·∫•y th√¥ng tin video l·∫ßn 1 (kh√¥ng d√πng cookie)
            video_info = await self.get_video_info(query)

            # N·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin, th·ª≠ l·∫°i l·∫ßn 2 (c√≥ d√πng cookie)
            if not video_info:
                logger.warning(f"Kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin video cho '{query}' l·∫ßn 1, th·ª≠ l·∫°i v·ªõi cookie...")
                video_info = await self.get_video_info(query, use_cookies=True)

            if not video_info:
                await interaction.edit_original_response(content=f"‚ùå Kh√¥ng t√¨m th·∫•y video cho '{query}'.")
                return

            if guild_id not in self.queues:
                self.queues[guild_id] = deque()
            video_info["origin_channel"] = interaction.channel
            self.queues[guild_id].append(video_info)

            embed = discord.Embed(
                title="‚úÖ ƒê√£ th√™m v√†o h√†ng ƒë·ª£i",
                description=f"[{video_info['title']}]({video_info['webpage_url']})",
                color=discord.Color.blue(),
            )
            await interaction.edit_original_response(content="", embed=embed)

            if guild_id not in self.now_playing:
                await self.play_next(guild_id)

    @commands.command(name="queue", aliases=["q"])
    async def queue(self, ctx: commands.Context) -> None:
        """Hi·ªÉn th·ªã danh s√°ch h√†ng ƒë·ª£i.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.queues or not self.queues[guild_id]:
            await ctx.send("üì≠ H√†ng ƒë·ª£i hi·ªán ƒëang tr·ªëng.")
            return

        embed = discord.Embed(
            title="üìú Danh s√°ch h√†ng ƒë·ª£i",
            description="\n".join(
                f"{i+1}. [{song['title']}]({song['webpage_url']}) ({song['duration']//60}:{song['duration']%60:02d})"
                for i, song in enumerate(self.queues[guild_id])
            ),
            color=discord.Color.purple(),
        )
        if guild_id in self.now_playing:
            embed.add_field(
                name="ƒêang ph√°t",
                value=f"[{self.now_playing[guild_id]['title']}]({self.now_playing[guild_id]['webpage_url']})",
                inline=False,
            )
        await ctx.send(embed=embed)
        
    @app_commands.command(name="queue", description="Hi·ªÉn th·ªã danh s√°ch h√†ng ƒë·ª£i")
    async def slash_queue(self, interaction: discord.Interaction) -> None:
        """Slash command hi·ªÉn th·ªã danh s√°ch h√†ng ƒë·ª£i.

        Args:
            interaction: T∆∞∆°ng t√°c t·ª´ ng∆∞·ªùi d√πng.
        """
        guild_id = interaction.guild.id
        if guild_id not in self.queues or not self.queues[guild_id]:
            await interaction.response.send_message("üì≠ H√†ng ƒë·ª£i hi·ªán ƒëang tr·ªëng.", ephemeral=True)
            return

        embed = discord.Embed(
            title="üìú Danh s√°ch h√†ng ƒë·ª£i",
            description="\n".join(
                f"{i+1}. [{song['title']}]({song['webpage_url']}) ({song['duration']//60}:{song['duration']%60:02d})"
                for i, song in enumerate(self.queues[guild_id])
            ),
            color=discord.Color.purple(),
        )
        if guild_id in self.now_playing:
            embed.add_field(
                name="ƒêang ph√°t",
                value=f"[{self.now_playing[guild_id]['title']}]({self.now_playing[guild_id]['webpage_url']})",
                inline=False,
            )
        await interaction.response.send_message(embed=embed)

    @commands.command(name="nowplaying", aliases=["np"])
    async def now_playing(self, ctx: commands.Context) -> None:
        """Hi·ªÉn th·ªã b√†i ƒëang ph√°t.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.now_playing:
            await ctx.send("üì≠ Hi·ªán kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t.")
            return

        song = self.now_playing[guild_id]
        embed = discord.Embed(
            title="üéµ ƒêang ph√°t",
            description=(
                f"[{song['title']}]({song['webpage_url']})\n"
                f"**Ng∆∞·ªùi t·∫£i l√™n**: {song['uploader']}\n"
                f"**Th·ªùi l∆∞·ª£ng**: {song['duration']//60}:{song['duration']%60:02d}"
            ),
            color=discord.Color.green(),
        )
        await ctx.send(embed=embed)
        
    @app_commands.command(name="nowplaying", description="Hi·ªÉn th·ªã b√†i ƒëang ph√°t")
    async def slash_now_playing(self, interaction: discord.Interaction) -> None:
        """Slash command hi·ªÉn th·ªã b√†i ƒëang ph√°t.

        Args:
            interaction: T∆∞∆°ng t√°c t·ª´ ng∆∞·ªùi d√πng.
        """
        guild_id = interaction.guild.id
        if guild_id not in self.now_playing:
            await interaction.response.send_message("üì≠ Hi·ªán kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t.", ephemeral=True)
            return

        song = self.now_playing[guild_id]
        embed = discord.Embed(
            title="üéµ ƒêang ph√°t",
            description=(
                f"[{song['title']}]({song['webpage_url']})\n"
                f"**Ng∆∞·ªùi t·∫£i l√™n**: {song['uploader']}\n"
                f"**Th·ªùi l∆∞·ª£ng**: {song['duration']//60}:{song['duration']%60:02d}"
            ),
            color=discord.Color.green(),
        )
        await interaction.response.send_message(embed=embed)

    @commands.command(name="skip", aliases=["s"])
    async def skip(self, ctx: commands.Context) -> None:
        """B·ªè qua b√†i hi·ªán t·∫°i.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.voice_clients or not self.voice_clients[guild_id].is_playing():
            await ctx.send("‚ùå Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t.")
            return

        self.voice_clients[guild_id].stop()
        await ctx.send("‚è≠ ƒê√£ b·ªè qua b√†i hi·ªán t·∫°i.")
        logger.info(f"‚úÖ ƒê√£ b·ªè qua b√†i trong guild {guild_id}")
        
    @app_commands.command(name="skip", description="B·ªè qua b√†i hi·ªán t·∫°i")
    async def slash_skip(self, interaction: discord.Interaction) -> None:
        """Slash command b·ªè qua b√†i hi·ªán t·∫°i.

        Args:
            interaction: T∆∞∆°ng t√°c t·ª´ ng∆∞·ªùi d√πng.
        """
        guild_id = interaction.guild.id
        if guild_id not in self.voice_clients or not self.voice_clients[guild_id].is_playing():
            await interaction.response.send_message("‚ùå Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t.", ephemeral=True)
            return

        self.voice_clients[guild_id].stop()
        await interaction.response.send_message("‚è≠ ƒê√£ b·ªè qua b√†i hi·ªán t·∫°i.")
        logger.info(f"‚úÖ ƒê√£ b·ªè qua b√†i trong guild {guild_id}")

    @commands.command(name="pause")
    async def pause(self, ctx: commands.Context) -> None:
        """T·∫°m d·ª´ng nh·∫°c.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.voice_clients:
            await ctx.send("‚ùå Bot kh√¥ng ·ªü trong voice channel.")
            return

        vc = self.voice_clients[guild_id]

        if vc.is_playing():
            vc.pause()
            await ctx.send("‚è∏ ƒê√£ t·∫°m d·ª´ng nh·∫°c.")
            logger.info(f"‚úÖ ƒê√£ t·∫°m d·ª´ng nh·∫°c trong guild {guild_id}")
        elif vc.is_paused():
            vc.resume()
            await ctx.send("‚ñ∂ ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c.")
            logger.info(f"‚úÖ ƒê√£ ti·∫øp t·ª•c nh·∫°c trong guild {guild_id}")
        else:
            await ctx.send("‚ùå Kh√¥ng c√≥ nh·∫°c ƒë·ªÉ d·ª´ng/ti·∫øp t·ª•c.")

    @app_commands.command(name="pause", description="T·∫°m d·ª´ng ho·∫∑c ti·∫øp t·ª•c nh·∫°c")
    async def slash_pause(self, interaction: discord.Interaction) -> None:
        """Slash command t·∫°m d·ª´ng nh·∫°c.

        Args:
            interaction: T∆∞∆°ng t√°c t·ª´ ng∆∞·ªùi d√πng.
        """
        guild_id = interaction.guild.id
        if guild_id not in self.voice_clients:
            await interaction.response.send_message("‚ùå Bot kh√¥ng ·ªü trong voice channel.", ephemeral=True)
            return

        vc = self.voice_clients[guild_id]

        if vc.is_playing():
            vc.pause()
            await interaction.response.send_message("‚è∏ ƒê√£ t·∫°m d·ª´ng nh·∫°c.")
            logger.info(f"‚úÖ ƒê√£ t·∫°m d·ª´ng nh·∫°c trong guild {guild_id}")
        elif vc.is_paused():
            vc.resume()
            await interaction.response.send_message("‚ñ∂ ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c.")
            logger.info(f"‚úÖ ƒê√£ ti·∫øp t·ª•c nh·∫°c trong guild {guild_id}")
        else:
            await interaction.response.send_message("‚ùå Kh√¥ng c√≥ nh·∫°c ƒë·ªÉ d·ª´ng/ti·∫øp t·ª•c.", ephemeral=True)

    @commands.command(name="resume")
    async def resume(self, ctx: commands.Context) -> None:
        """Ti·∫øp t·ª•c ph√°t nh·∫°c.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.voice_clients or not self.voice_clients[guild_id].is_paused():
            await ctx.send("‚ùå Nh·∫°c kh√¥ng b·ªã t·∫°m d·ª´ng.")
            return

        self.voice_clients[guild_id].resume()
        await ctx.send("‚ñ∂ ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c.")
        logger.info(f"‚úÖ ƒê√£ ti·∫øp t·ª•c nh·∫°c trong guild {guild_id}")
        
    @app_commands.command(name="resume", description="Ti·∫øp t·ª•c ph√°t nh·∫°c")
    async def slash_resume(self, interaction: discord.Interaction) -> None:
        """Slash command ti·∫øp t·ª•c ph√°t nh·∫°c.

        Args:
            interaction: T∆∞∆°ng t√°c t·ª´ ng∆∞·ªùi d√πng.
        """
        guild_id = interaction.guild.id
        if guild_id not in self.voice_clients or not self.voice_clients[guild_id].is_paused():
            await interaction.response.send_message("‚ùå Nh·∫°c kh√¥ng b·ªã t·∫°m d·ª´ng.", ephemeral=True)
            return

        self.voice_clients[guild_id].resume()
        await interaction.response.send_message("‚ñ∂ ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c.")
        logger.info(f"‚úÖ ƒê√£ ti·∫øp t·ª•c nh·∫°c trong guild {guild_id}")

    @commands.command(name="stop")
    async def stop(self, ctx: commands.Context) -> None:
        """D·ª´ng nh·∫°c v√† x√≥a h√†ng ƒë·ª£i.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.voice_clients:
            await ctx.send("‚ùå Bot kh√¥ng ·ªü trong voice channel.")
            return

        # H·ªßy b·ªô ƒë·∫øm th·ªùi gian kh√¥ng ho·∫°t ƒë·ªông
        if guild_id in self.inactivity_timers:
            self.inactivity_timers[guild_id].cancel()
            self.inactivity_timers.pop(guild_id)

        if guild_id in self.queues:
            self.queues[guild_id].clear()
        self.now_playing.pop(guild_id, None)
        self.voice_clients[guild_id].stop()
        await self.voice_clients[guild_id].disconnect()
        self.voice_clients.pop(guild_id)
        await ctx.send("‚èπ ƒê√£ d·ª´ng nh·∫°c v√† r·ªùi voice channel.")
        logger.info(f"‚úÖ ƒê√£ d·ª´ng nh·∫°c trong guild {guild_id}")

    @app_commands.command(name="stop", description="D·ª´ng nh·∫°c v√† x√≥a h√†ng ƒë·ª£i")
    async def slash_stop(self, interaction: discord.Interaction) -> None:
        guild_id = interaction.guild.id
        if guild_id not in self.voice_clients:
            await interaction.response.send_message("‚ùå Bot kh√¥ng ·ªü trong voice channel.", ephemeral=True)
            return

        # H·ªßy b·ªô ƒë·∫øm th·ªùi gian kh√¥ng ho·∫°t ƒë·ªông
        if guild_id in self.inactivity_timers:
            self.inactivity_timers[guild_id].cancel()
            self.inactivity_timers.pop(guild_id)

        # Tr·∫£ l·ªùi ngay cho Discord
        await interaction.response.send_message("‚èπ ƒêang d·ª´ng nh·∫°c v√† tho√°t...")

        if guild_id in self.queues:
            self.queues[guild_id].clear()
        self.now_playing.pop(guild_id, None)

        self.voice_clients[guild_id].stop()
        await self.voice_clients[guild_id].disconnect()
        self.voice_clients.pop(guild_id)

        logger.info(f"‚úÖ ƒê√£ d·ª´ng nh·∫°c trong guild {guild_id}")

    @commands.command(name="clear")
    async def clear(self, ctx: commands.Context) -> None:
        """X√≥a to√†n b·ªô h√†ng ƒë·ª£i.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.queues or not self.queues[guild_id]:
            await ctx.send("üì≠ H√†ng ƒë·ª£i hi·ªán ƒëang tr·ªëng.")
            return

        self.queues[guild_id].clear()
        await ctx.send("üóë ƒê√£ x√≥a to√†n b·ªô h√†ng ƒë·ª£i.")
        logger.info(f"‚úÖ ƒê√£ x√≥a h√†ng ƒë·ª£i trong guild {guild_id}")
        
    @app_commands.command(name="clear", description="X√≥a to√†n b·ªô h√†ng ƒë·ª£i")
    async def slash_clear(self, interaction: discord.Interaction) -> None:
        """Slash command x√≥a to√†n b·ªô h√†ng ƒë·ª£i.

        Args:
            interaction: T∆∞∆°ng t√°c t·ª´ ng∆∞·ªùi d√πng.
        """
        guild_id = interaction.guild.id
        if guild_id not in self.queues or not self.queues[guild_id]:
            await interaction.response.send_message("üì≠ H√†ng ƒë·ª£i hi·ªán ƒëang tr·ªëng.", ephemeral=True)
            return

        self.queues[guild_id].clear()
        await interaction.response.send_message("üóë ƒê√£ x√≥a to√†n b·ªô h√†ng ƒë·ª£i.")
        logger.info(f"‚úÖ ƒê√£ x√≥a h√†ng ƒë·ª£i trong guild {guild_id}")

    @commands.command(name="remove", aliases=["rm"])
    async def remove(self, ctx: commands.Context, index: int) -> None:
        """X√≥a b√†i ·ªü v·ªã tr√≠ c·ª• th·ªÉ trong h√†ng ƒë·ª£i.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
            index: V·ªã tr√≠ b√†i c·∫ßn x√≥a (b·∫Øt ƒë·∫ßu t·ª´ 1).
        """
        guild_id = ctx.guild.id
        if guild_id not in self.queues or not self.queues[guild_id]:
            await ctx.send("üì≠ H√†ng ƒë·ª£i hi·ªán ƒëang tr·ªëng.")
            return

        if index < 1 or index > len(self.queues[guild_id]):
            await ctx.send("‚ùå V·ªã tr√≠ kh√¥ng h·ª£p l·ªá.")
            return

        song = list(self.queues[guild_id])[index - 1]
        self.queues[guild_id].remove(song)
        await ctx.send(f"üóë ƒê√£ x√≥a: {song['title']}.")
        logger.info(f"‚úÖ ƒê√£ x√≥a b√†i {song['title']} trong guild {guild_id}")
        
    @app_commands.command(name="remove", description="X√≥a b√†i ·ªü v·ªã tr√≠ c·ª• th·ªÉ trong h√†ng ƒë·ª£i")
    @app_commands.describe(index="V·ªã tr√≠ b√†i c·∫ßn x√≥a (b·∫Øt ƒë·∫ßu t·ª´ 1)")
    async def slash_remove(self, interaction: discord.Interaction, index: int) -> None:
        """Slash command x√≥a b√†i ·ªü v·ªã tr√≠ c·ª• th·ªÉ trong h√†ng ƒë·ª£i.

        Args:
            interaction: T∆∞∆°ng t√°c t·ª´ ng∆∞·ªùi d√πng.
            index: V·ªã tr√≠ b√†i c·∫ßn x√≥a (b·∫Øt ƒë·∫ßu t·ª´ 1).
        """
        guild_id = interaction.guild.id
        if guild_id not in self.queues or not self.queues[guild_id]:
            await interaction.response.send_message("üì≠ H√†ng ƒë·ª£i hi·ªán ƒëang tr·ªëng.", ephemeral=True)
            return

        if index < 1 or index > len(self.queues[guild_id]):
            await interaction.response.send_message("‚ùå V·ªã tr√≠ kh√¥ng h·ª£p l·ªá.", ephemeral=True)
            return

        song = list(self.queues[guild_id])[index - 1]
        self.queues[guild_id].remove(song)
        await interaction.response.send_message(f"üóë ƒê√£ x√≥a: {song['title']}.")
        logger.info(f"‚úÖ ƒê√£ x√≥a b√†i {song['title']} trong guild {guild_id}")

    @commands.command(name="leave")
    async def leave(self, ctx: commands.Context) -> None:
        """R·ªùi voice channel.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.voice_clients:
            await ctx.send("‚ùå Bot kh√¥ng ·ªü trong voice channel.")
            return

        # H·ªßy b·ªô ƒë·∫øm th·ªùi gian kh√¥ng ho·∫°t ƒë·ªông
        if guild_id in self.inactivity_timers:
            self.inactivity_timers[guild_id].cancel()
            self.inactivity_timers.pop(guild_id)

        if guild_id in self.queues:
            self.queues[guild_id].clear()
        self.now_playing.pop(guild_id, None)
        await self.voice_clients[guild_id].disconnect()
        self.voice_clients.pop(guild_id)
        await ctx.send("üëã ƒê√£ r·ªùi voice channel.")
        logger.info(f"‚úÖ ƒê√£ r·ªùi voice channel trong guild {guild_id}")
        
    @app_commands.command(name="leave", description="R·ªùi voice channel")
    async def slash_leave(self, interaction: discord.Interaction) -> None:
        """Slash command r·ªùi voice channel.

        Args:
            interaction: T∆∞∆°ng t√°c t·ª´ ng∆∞·ªùi d√πng.
        """
        guild_id = interaction.guild.id
        if guild_id not in self.voice_clients:
            await interaction.response.send_message("‚ùå Bot kh√¥ng ·ªü trong voice channel.", ephemeral=True)
            return

        # H·ªßy b·ªô ƒë·∫øm th·ªùi gian kh√¥ng ho·∫°t ƒë·ªông
        if guild_id in self.inactivity_timers:
            self.inactivity_timers[guild_id].cancel()
            self.inactivity_timers.pop(guild_id)

        if guild_id in self.queues:
            self.queues[guild_id].clear()
        self.now_playing.pop(guild_id, None)
        await self.voice_clients[guild_id].disconnect()
        self.voice_clients.pop(guild_id)
        await interaction.response.send_message("üëã ƒê√£ r·ªùi voice channel.")
        logger.info(f"‚úÖ ƒê√£ r·ªùi voice channel trong guild {guild_id}")

    async def cog_unload(self) -> None:
        """Ng·∫Øt k·∫øt n·ªëi t·∫•t c·∫£ voice clients khi cog ƒë∆∞·ª£c g·ª°."""
        # H·ªßy t·∫•t c·∫£ b·ªô ƒë·∫øm th·ªùi gian kh√¥ng ho·∫°t ƒë·ªông
        for timer in self.inactivity_timers.values():
            timer.cancel()
        self.inactivity_timers.clear()
        
        for voice_client in self.voice_clients.values():
            await voice_client.disconnect()
        self.voice_clients.clear()