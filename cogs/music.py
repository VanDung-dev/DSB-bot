import asyncio
import json
import logging
from collections import deque
from pathlib import Path
from typing import Dict, Optional

import discord
import yt_dlp
from discord.ext import commands

# C·∫•u h√¨nh logger
logger = logging.getLogger(__name__)


class MusicSearch(commands.Cog):
    """Cog x·ª≠ l√Ω c√°c l·ªánh ph√°t nh·∫°c t·ª´ YouTube."""

    FFMPEG_OPTIONS = {
        "before_options": "-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5",
        "options": "-vn",
    }

    def __init__(self, bot: commands.Bot) -> None:
        """Kh·ªüi t·∫°o cog MusicSearch.

        Args:
            bot: ƒê·ªëi t∆∞·ª£ng bot Discord.
        """
        self.bot = bot
        self.queues: Dict[int, deque] = {}
        self.now_playing: Dict[int, dict] = {}
        self.voice_clients: Dict[int, discord.VoiceClient] = {}
        self.ydl_options = self.load_ydl_config()

    @staticmethod
    def load_ydl_config() -> dict:
        """T·∫£i c·∫•u h√¨nh yt_dlp t·ª´ file JSON.

        Returns:
            C·∫•u h√¨nh yt_dlp.

        Raises:
            FileNotFoundError: N·∫øu file ydl_config.json kh√¥ng t·ªìn t·∫°i.
            json.JSONDecodeError: N·∫øu file JSON kh√¥ng h·ª£p l·ªá.
        """
        config_file = Path("ydl_config.json")
        try:
            if config_file.exists():
                with config_file.open("r", encoding="utf-8") as f:
                    return json.load(f)
            raise FileNotFoundError("ydl_config.json kh√¥ng t·ªìn t·∫°i")
        except json.JSONDecodeError as e:
            logger.error(f"‚ùå L·ªói khi ƒë·ªçc ydl_config.json: {e}")
            raise
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi t·∫£i ydl_config.json: {e}")
            raise

    async def get_video_info(self, query: str) -> Optional[dict]:
        """L·∫•y th√¥ng tin video t·ª´ YouTube.

        Args:
            query: URL ho·∫∑c t·ª´ kh√≥a t√¨m ki·∫øm.

        Returns:
            Th√¥ng tin video (title, url, webpage_url, duration, uploader) ho·∫∑c None n·∫øu l·ªói.
        """
        try:
            with yt_dlp.YoutubeDL(self.ydl_options) as ydl:
                loop = asyncio.get_event_loop()
                info = await loop.run_in_executor(None, lambda: ydl.extract_info(query, download=False))
                if "entries" in info:
                    info = info["entries"][0]
                return {
                    "title": info.get("title", "Unknown Title"),
                    "url": info.get("url", ""),
                    "webpage_url": info.get("webpage_url", ""),
                    "duration": info.get("duration", 0),
                    "uploader": info.get("uploader", "Unknown Uploader"),
                }
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi t·∫£i th√¥ng tin video: {e}")
            return None

    async def play_next(self, guild_id: int) -> None:
        """Ph√°t b√†i ti·∫øp theo trong h√†ng ƒë·ª£i.

        Args:
            guild_id: ID c·ªßa server Discord.
        """
        if guild_id not in self.queues or not self.queues[guild_id]:
            self.now_playing.pop(guild_id, None)
            if guild_id in self.voice_clients:
                await self.voice_clients[guild_id].disconnect()
                self.voice_clients.pop(guild_id)
            return

        song = self.queues[guild_id].popleft()
        self.now_playing[guild_id] = song

        try:
            source = discord.FFmpegPCMAudio(song["url"], **self.FFMPEG_OPTIONS)
            self.voice_clients[guild_id].play(
                source,
                after=lambda e: asyncio.run_coroutine_threadsafe(self.play_next(guild_id), self.bot.loop),
            )
            embed = discord.Embed(
                title="üéµ ƒêang ph√°t",
                description=(
                    f"[{song['title']}]({song['webpage_url']})\n"
                    f"**Ng∆∞·ªùi t·∫£i l√™n**: {song['uploader']}\n"
                    f"**Th·ªùi l∆∞·ª£ng**: {song['duration']//60}:{song['duration']%60:02d}"
                ),
                color=discord.Color.green(),
            )
            await self.voice_clients[guild_id].channel.send(embed=embed)
            logger.info(f"‚úÖ ƒêang ph√°t: {song['title']} trong guild {guild_id}")
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi ph√°t nh·∫°c: {e}")
            await self.play_next(guild_id)

    @commands.command(name="play", aliases=["p"])
    async def play(self, ctx: commands.Context, *, query: str) -> None:
        """Ph√°t nh·∫°c t·ª´ URL ho·∫∑c t√¨m ki·∫øm tr√™n YouTube.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
            query: URL ho·∫∑c t·ª´ kh√≥a t√¨m ki·∫øm.
        """
        if not ctx.author.voice:
            await ctx.send("‚ùå B·∫°n c·∫ßn ·ªü trong voice channel ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y.")
            return

        voice_channel = ctx.author.voice.channel
        guild_id = ctx.guild.id

        if guild_id not in self.voice_clients:
            try:
                self.voice_clients[guild_id] = await voice_channel.connect()
            except discord.errors.ClientException:
                await ctx.send("‚ùå Bot ƒë√£ ·ªü trong voice channel kh√°c.")
                return
            except Exception as e:
                logger.error(f"‚ùå L·ªói khi k·∫øt n·ªëi voice channel: {e}")
                await ctx.send("‚ùå L·ªói khi k·∫øt n·ªëi voice channel.")
                return

        search_msg = await ctx.send(f"üîç ƒêang t√¨m: **{query}**...")
        video_info = await self.get_video_info(query)
        if not video_info:
            await search_msg.edit(content="‚ùå Kh√¥ng t√¨m th·∫•y video.")
            return

        if guild_id not in self.queues:
            self.queues[guild_id] = deque()
        self.queues[guild_id].append(video_info)

        embed = discord.Embed(
            title="‚úÖ ƒê√£ th√™m v√†o h√†ng ƒë·ª£i",
            description=(
                f"[{video_info['title']}]({video_info['webpage_url']})\n"
                f"**Ng∆∞·ªùi t·∫£i l√™n**: {video_info['uploader']}\n"
                f"**Th·ªùi l∆∞·ª£ng**: {video_info['duration']//60}:{video_info['duration']%60:02d}"
            ),
            color=discord.Color.blue(),
        )
        await search_msg.edit(content="", embed=embed)
        logger.info(f"‚úÖ ƒê√£ th√™m: {video_info['title']} v√†o h√†ng ƒë·ª£i guild {guild_id}")

        if guild_id not in self.now_playing:
            await self.play_next(guild_id)

    @commands.command(name="queue", aliases=["q"])
    async def queue(self, ctx: commands.Context) -> None:
        """Hi·ªÉn th·ªã danh s√°ch h√†ng ƒë·ª£i.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.queues or not self.queues[guild_id]:
            await ctx.send("üì≠ H√†ng ƒë·ª£i hi·ªán ƒëang tr·ªëng.")
            return

        embed = discord.Embed(
            title="üìú Danh s√°ch h√†ng ƒë·ª£i",
            description="\n".join(
                f"{i+1}. [{song['title']}]({song['webpage_url']}) ({song['duration']//60}:{song['duration']%60:02d})"
                for i, song in enumerate(self.queues[guild_id])
            ),
            color=discord.Color.purple(),
        )
        if guild_id in self.now_playing:
            embed.add_field(
                name="ƒêang ph√°t",
                value=f"[{self.now_playing[guild_id]['title']}]({self.now_playing[guild_id]['webpage_url']})",
                inline=False,
            )
        await ctx.send(embed=embed)

    @commands.command(name="nowplaying", aliases=["np"])
    async def now_playing(self, ctx: commands.Context) -> None:
        """Hi·ªÉn th·ªã b√†i ƒëang ph√°t.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.now_playing:
            await ctx.send("üì≠ Hi·ªán kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t.")
            return

        song = self.now_playing[guild_id]
        embed = discord.Embed(
            title="üéµ ƒêang ph√°t",
            description=(
                f"[{song['title']}]({song['webpage_url']})\n"
                f"**Ng∆∞·ªùi t·∫£i l√™n**: {song['uploader']}\n"
                f"**Th·ªùi l∆∞·ª£ng**: {song['duration']//60}:{song['duration']%60:02d}"
            ),
            color=discord.Color.green(),
        )
        await ctx.send(embed=embed)

    @commands.command(name="skip", aliases=["s"])
    async def skip(self, ctx: commands.Context) -> None:
        """B·ªè qua b√†i hi·ªán t·∫°i.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.voice_clients or not self.voice_clients[guild_id].is_playing():
            await ctx.send("‚ùå Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t.")
            return

        self.voice_clients[guild_id].stop()
        await ctx.send("‚è≠ ƒê√£ b·ªè qua b√†i hi·ªán t·∫°i.")
        logger.info(f"‚úÖ ƒê√£ b·ªè qua b√†i trong guild {guild_id}")

    @commands.command(name="pause")
    async def pause(self, ctx: commands.Context) -> None:
        """T·∫°m d·ª´ng nh·∫°c.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.voice_clients or not self.voice_clients[guild_id].is_playing():
            await ctx.send("‚ùå Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t.")
            return

        self.voice_clients[guild_id].pause()
        await ctx.send("‚è∏ ƒê√£ t·∫°m d·ª´ng nh·∫°c.")
        logger.info(f"‚úÖ ƒê√£ t·∫°m d·ª´ng nh·∫°c trong guild {guild_id}")

    @commands.command(name="resume")
    async def resume(self, ctx: commands.Context) -> None:
        """Ti·∫øp t·ª•c ph√°t nh·∫°c.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.voice_clients or not self.voice_clients[guild_id].is_paused():
            await ctx.send("‚ùå Nh·∫°c kh√¥ng b·ªã t·∫°m d·ª´ng.")
            return

        self.voice_clients[guild_id].resume()
        await ctx.send("‚ñ∂ ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c.")
        logger.info(f"‚úÖ ƒê√£ ti·∫øp t·ª•c nh·∫°c trong guild {guild_id}")

    @commands.command(name="stop")
    async def stop(self, ctx: commands.Context) -> None:
        """D·ª´ng nh·∫°c v√† x√≥a h√†ng ƒë·ª£i.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.voice_clients:
            await ctx.send("‚ùå Bot kh√¥ng ·ªü trong voice channel.")
            return

        if guild_id in self.queues:
            self.queues[guild_id].clear()
        self.now_playing.pop(guild_id, None)
        self.voice_clients[guild_id].stop()
        await self.voice_clients[guild_id].disconnect()
        self.voice_clients.pop(guild_id)
        await ctx.send("‚èπ ƒê√£ d·ª´ng nh·∫°c v√† r·ªùi voice channel.")
        logger.info(f"‚úÖ ƒê√£ d·ª´ng nh·∫°c trong guild {guild_id}")

    @commands.command(name="clear")
    async def clear(self, ctx: commands.Context) -> None:
        """X√≥a to√†n b·ªô h√†ng ƒë·ª£i.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.queues or not self.queues[guild_id]:
            await ctx.send("üì≠ H√†ng ƒë·ª£i hi·ªán ƒëang tr·ªëng.")
            return

        self.queues[guild_id].clear()
        await ctx.send("üóë ƒê√£ x√≥a to√†n b·ªô h√†ng ƒë·ª£i.")
        logger.info(f"‚úÖ ƒê√£ x√≥a h√†ng ƒë·ª£i trong guild {guild_id}")

    @commands.command(name="remove", aliases=["rm"])
    async def remove(self, ctx: commands.Context, index: int) -> None:
        """X√≥a b√†i ·ªü v·ªã tr√≠ c·ª• th·ªÉ trong h√†ng ƒë·ª£i.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
            index: V·ªã tr√≠ b√†i c·∫ßn x√≥a (b·∫Øt ƒë·∫ßu t·ª´ 1).
        """
        guild_id = ctx.guild.id
        if guild_id not in self.queues or not self.queues[guild_id]:
            await ctx.send("üì≠ H√†ng ƒë·ª£i hi·ªán ƒëang tr·ªëng.")
            return

        if index < 1 or index > len(self.queues[guild_id]):
            await ctx.send("‚ùå V·ªã tr√≠ kh√¥ng h·ª£p l·ªá.")
            return

        song = list(self.queues[guild_id])[index - 1]
        self.queues[guild_id].remove(song)
        await ctx.send(f"üóë ƒê√£ x√≥a: {song['title']}.")
        logger.info(f"‚úÖ ƒê√£ x√≥a b√†i {song['title']} trong guild {guild_id}")

    @commands.command(name="leave")
    async def leave(self, ctx: commands.Context) -> None:
        """R·ªùi voice channel.

        Args:
            ctx: Ng·ªØ c·∫£nh l·ªánh Discord.
        """
        guild_id = ctx.guild.id
        if guild_id not in self.voice_clients:
            await ctx.send("‚ùå Bot kh√¥ng ·ªü trong voice channel.")
            return

        if guild_id in self.queues:
            self.queues[guild_id].clear()
        self.now_playing.pop(guild_id, None)
        await self.voice_clients[guild_id].disconnect()
        self.voice_clients.pop(guild_id)
        await ctx.send("üëã ƒê√£ r·ªùi voice channel.")
        logger.info(f"‚úÖ ƒê√£ r·ªùi voice channel trong guild {guild_id}")

    async def cog_unload(self) -> None:
        """Ng·∫Øt k·∫øt n·ªëi t·∫•t c·∫£ voice clients khi cog ƒë∆∞·ª£c g·ª°."""
        for voice_client in self.voice_clients.values():
            await voice_client.disconnect()
        self.voice_clients.clear()